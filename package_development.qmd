---
lightbox: true
---
# Package Development

One of the beautiful things of Data Science at SAMY is that you get to choose your path between research, development, or a hybrid. If you're reading this, you've probably decided that you want to explore some development. What better way to start than building your own package?

For a high-level overview of our existing packages, refer to the [our packages](packages.qmd) document.

We build packages because they are convenient ways to share our code & data and democratise access to our tools - besides, that Google Doc of functions is getting heavy, and copying & pasting code from project to project is getting tiresome. Eventually you'll want the familiar `library()` syntax.

Historically our packages have been built in R for two key reasons:

1. The profile/experience of people in the team
2. The ecosystem for building packages is well-maintained and documented

In recent times we have moved to more of a hybrid approach between R & Python - the former we find to be considerably more easy to use for data wrangling and visualisation, and the latter for modelling and anything to do with LLMs. Internal development for Python has lagged behind R, but we expect this to change over time as we seek to be tool agnostic and focus on the right tool for the job at hand.

<details>
<summary> Reticulate </summary>
Reticulate is an R package that allows us to import Python packages and functions in R. Currently this is a one-way street - we can't use reticulate to import R functions and packages. This has impacted our decision in the past, e.g. with BertopicR. We envisioned Insight Analysts using BertopicR as a drop-in or replacement for topic modelling with SegmentR. Weighing up the additional difficulty in development vs the time and resource necessary for Analysts to learn Python as well as R, we opted for reticulate.

Using reticulate requires managing Python environments from R, this leads to difficulties of its own.
</details>

# R

Here we'll look at how to get off the ground in R using {usethis}, {pkgdown}, {devtools}, {testthat} and {roxygen2}.

## Building your own package

The (nearly) DIY way:

This check-list should get you **most of the way** there, but it's always possible that we've forgotten something or there has been <s>a disturbance in the force</s> a change in the package ecosystem. When this happens, open up an issue or submit a PR and help the next person who comes along.

- [ ] Create a new repository on GitHub
- [ ] Clone the repository 

::: {.callout-tip collapse=true}
## folder management
Create a folder at your home directory named 'git_repos' and store all of your repositories here:
<pre>
mkdir ~/git_repos
cd ~/git_repos
git clone 'repo.url'
</pre>
:::

- [ ] Open RStudio and call `usethis::create_package()`
- [ ] `usethis::use_git()` in the console and commit files
- [ ] Check git has been set up with `usethis::git_sitrep()` (or `git status` in the terminal)
- [ ] Set an upstream branch e.g. `git remote add upstream <link_to_repo_main>` in the terminal
- [ ] `usethis::use_vignette()` to add a vignettes folder and start your first vignette
- [ ] Add individual functions/scripts with `use_r("script_name")` - these appear in your R/ folder
- [ ] Document each function following roxygen2's structure
- [ ] Call `use_package()` whenever you use an external package inside your package.

::: {.callout-tip collapse=true}
## DESCRIPTION
Your package will now have a DESCRIPTION file, add external packages your package requires to Imports. Add additional packages used in vignettes to Suggests. - But be careful, it's generally not advisable to use packages just for vignettes!

You can use the `usethis::use_latest_dependencies()` to add recent versions to your packages, but beware this can be restrictive. Ideally you would add the minimum package version necessary to run your code.
:::
- [ ] `usethis::use_*_license()` - default to usethis::use_mit_license()
- [ ] `usethis::use_testthat()` and `use_test("script_name")` to start writing units tests for your functions and add testthat to suggests.
- [ ] Call `usethis::use_readme_rmd()` to allow for markdown code chunks in your readme - just remember to `devtools::build_readme()` when you're done.
- [ ] Call `usethis::use_news_md()`
- [ ] When you're ready to add a website, call `usethis::use_pkgdown()` `pkgdown::init_site()`, `pkgdown::build_home_index()`, `pkgdown::build_search()`, `pkgdown::build_reference()`, `pgkdown::build_articles()`, and then `pkgdown::build_site()`
- [ ] Add each function to pkgdown.yml's reference section (we recommend viewing a working yml file from one of the other packages to get you started).

The Easy Way (Tidy functions)
Read through the [usethis-setup guide](https://usethis.r-lib.org/articles/usethis-setup.html) and then use the 
`usethis::create_tidy_package()` to create a package with some guardrails.

::: {.callout-tip}
## Guardrails or no guardrails?
The `usethis::create_tidy_package()` function is a helpful abstraction, but it will be better for your long-term development if you know how to do this stuff without the abstraction. That way, when you need to fix something, or do something slightly different than the prescribed way, you'll have a better chance of success.
:::

## Development workflow

:::: {.columns}
::: {.column width="30%"}
Once you've built the package there are some things you will want to do regularly to ensure your package stays in good shape. This is by no means an exhaustive list - be sure to add your tips & tricks as you amass them.
:::
::: {.column width="20%"}
:::
::: {.column}
![](img/bernie.png)
:::
::::
<br>

- [ ] Run `testthat::test_package()` often to check for regressions in your code
- [ ] Run `devtools::check()` occasionally to make sure you haven't made any obvious mistakes - try to keep notes, warnings and errors to 0!
- [ ] Use `devtools::load_all()` to reload the package when you've made changes.
- [ ] Use `pkgdown::build_site()` when you expect to see changes in your package's website
- [ ] Use `pkgdown::clean_site()` and `pkgdown::build_site()` when expected changes aren't reflecting in your preview

## Contributing to existing packages

- [ ] Pull current state of repo/package from origin	

- [ ] Create a new branch, can use `usethis::pr_init()` from usethis to make this a bit easier, otherwise `git checkout -b "branch_name"`

- [ ] Run `devtools::test()` `devtools::check()` at regular intervals, keep errors, warnings, notes down to minimum	

- [ ] Build out logic for new changes, add to R/ where necessary. `usethis::use_r()` function to add new scripts properly	

- [ ] Build out tests for new logic in tests/

- [ ] Ensure function-level documentation is added to any new logic, including @title, @description, @details, @param, @returns, @examples and @export if function is to be exported, or @internal otherwise. Let roxygen2 take care of @usage. 

- [ ] Keep re-running tests and check!

- [ ] If you're introducing something new, update package-level documentation e.g. vignettes and/or readme explaining what you've introduced and how it should be used. Provide examples where possible. If you're building out a new capability you may need a whole new vignette, use the `usethis::use_vignette()` function.

- [ ] If you're updating legacy code, check that vignettes are up-to-date with the changes you've made - we want to avoid code-documentation drift where possible.

- [ ] Add your function to the reference section in _pkgdown,yml if it's being exported.

- [ ] Run `pkgdown::clean_site()` and `pkgdown::build site()`, visually inspect each section of the site	

Pull request when ready.

### Code

Generally code should sit in the R/ folder, you can choose between a script per function or use scripts as modules, where a module is a particular use case, or logical unit. Historically we sided on the former, but as a package grows it can become difficult to manage/navigate, and we get a decoupling of logic. 

### Documentation

::::{.columns}
:::{.column width="40%"}
We use {roxygen2} tags to document our functions. Visit the [documenting functions](https://roxygen2.r-lib.org/articles/rd.html) article for a primer.

Using the roxygen2 skeleton leads to consistent documentation, check out `?ParseR::count_ngram` to see the rendered documentation. As you document your own functions, check out how their documentation renders too.

:::
:::{.column width="20%"}
:::
:::{.column width="40%"}
![](img/parser_documentation.png){width=50% height=50%}
:::
::::

### Data

You're probably going to need some data...
existing data...
adding new

### Website

# Python

### Continuous Integration/Continuous Deployment
R templates etc. from RStudio
Python templates
